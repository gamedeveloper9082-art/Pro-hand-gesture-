<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EyeGuard Pro | Instant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;800&display=swap');
        <link rel="manifest" href="manifest.json">

<!-- For PWA icons -->
<link rel="icon" type="image/png" href="logo.png">
<link rel="apple-touch-icon" href="logo.png">

        body {
            font-family: 'JetBrains Mono', monospace;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow: hidden;
            user-select: none;
        }

        /* PIP Camera Container */
        #cam-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 160px;
            border: 2px solid #334155;
            border-radius: 12px;
            overflow: hidden;
            z-index: 50;
            background: #000;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
        }

        /* Video & Canvas Stacked & Mirrored */
        #webcam, #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1); /* Mirror Effect */
            object-fit: cover;
        }

        #output_canvas {
            z-index: 10; /* Canvas on top of video */
        }

        /* Danger Red Pulse */
        .alarm-active {
            animation: panic-mode 0.3s infinite;
        }

        @keyframes panic-mode {
            0% { background-color: #0f172a; box-shadow: inset 0 0 0 red; }
            50% { background-color: #450a0a; box-shadow: inset 0 0 100px red; }
            100% { background-color: #0f172a; box-shadow: inset 0 0 0 red; }
        }

        /* Logs */
        #system-log {
            font-size: 10px;
            color: #64748b;
            margin-top: 20px;
            background: #1e293b;
            padding: 10px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            min-height: 40px;
            max-height: 100px;
            overflow-y: auto;
            border: 1px solid #334155;
        }
        .log-success { color: #22c55e; }
        .log-warn { color: #f59e0b; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative">

    <!-- Main HUD -->
    <div class="z-10 flex flex-col items-center space-y-6 w-full px-6">
        
        <!-- Icon -->
        <div id="main-icon" class="text-7xl transition-transform duration-300">üëÅÔ∏è</div>

        <!-- Status Text -->
        <div class="text-center">
            <h1 id="status-header" class="text-4xl font-extrabold tracking-tighter text-blue-500">
                LOADING...
            </h1>
            <p id="status-sub" class="text-sm text-slate-400 mt-2">Initializing AI Vision</p>
        </div>

        <!-- Closure Meter -->
        <div class="w-full max-w-xs bg-slate-800 h-4 rounded-full overflow-hidden relative mt-4 border border-slate-700">
            <div id="blink-bar" class="h-full bg-emerald-500 w-0 transition-all duration-75"></div>
        </div>
        <p class="text-xs text-slate-500 font-bold">EYE CLOSURE LEVEL</p>

        <!-- Start Button -->
        <button id="start-btn" class="hidden w-full max-w-xs py-4 bg-emerald-600 hover:bg-emerald-500 text-white font-bold rounded-xl shadow-lg transition-all active:scale-95 border-b-4 border-emerald-800">
            ACTIVATE SYSTEM
        </button>

        <!-- Logs -->
        <div id="system-log">
            <div>> Booting EyeGuard Pro...</div>
        </div>

        <!-- Settings -->
        <div id="settings-area" class="hidden w-full max-w-xs mt-4 p-4 bg-slate-900 rounded-xl border border-slate-800">
            <label class="flex justify-between text-xs font-bold text-slate-400 mb-2">
                <span>SENSITIVITY</span>
                <span id="sens-val">50%</span>
            </label>
            <input type="range" id="sensitivity" min="0.3" max="0.7" step="0.05" value="0.5" class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer">
        </div>
    </div>

    <!-- Camera + Canvas Overlay -->
    <div id="cam-wrapper">
        <video id="webcam" autoplay playsinline muted></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script type="module">
        import {
            FaceLandmarker,
            FilesetResolver
        } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm";

        // --- UI Elements ---
        const logBox = document.getElementById('system-log');
        const statusHeader = document.getElementById('status-header');
        const statusSub = document.getElementById('status-sub');
        const mainIcon = document.getElementById('main-icon');
        const startBtn = document.getElementById('start-btn');
        const video = document.getElementById('webcam');
        const canvas = document.getElementById('output_canvas');
        const canvasCtx = canvas.getContext('2d');
        const blinkBar = document.getElementById('blink-bar');
        const settingsArea = document.getElementById('settings-area');
        const sensitivityInput = document.getElementById('sensitivity');
        const sensVal = document.getElementById('sens-val');

        // --- System Variables ---
        let faceLandmarker;
        let lastVideoTime = -1;
        let isMonitoring = false;
        let eyesClosedStart = 0;
        let alarmTriggered = false;
        
        // --- CONFIGURATION ---
        let BLINK_THRESHOLD = 0.5; 
        // UPDATED: Reduced from 1200 to 300 for "Instant" feel
        // 300ms allows for a normal blink (approx 100-150ms) without triggering
        const ALARM_DELAY_MS = 300; 

        // --- Audio Engine ---
        let audioCtx;
        let oscillator;
        let gainNode;
        let isSirenOn = false;

        // --- Eye Landmark Indices (MediaPipe Face Mesh) ---
        // These indices form the loop around the eyes
        const LEFT_EYE_INDICES = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246, 33];
        const RIGHT_EYE_INDICES = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398, 362];

        function log(msg, type = 'success') {
            const div = document.createElement('div');
            div.innerText = `> ${msg}`;
            div.className = `log-${type}`;
            logBox.appendChild(div);
            logBox.scrollTop = logBox.scrollHeight;
        }

        // --- 1. Initialize AI ---
        async function initAI() {
            try {
                log("Downloading AI Brain...", "warn");
                const filesetResolver = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
                );
                
                faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU" // Attempts GPU first
                    },
                    outputFaceBlendshapes: true,
                    runningMode: "VIDEO",
                    numFaces: 1
                });

                log("AI Model Ready", "success");
                statusHeader.innerText = "READY";
                statusHeader.className = "text-4xl font-extrabold text-emerald-400";
                statusSub.innerText = "System Standby";
                startBtn.classList.remove("hidden");

            } catch (e) {
                log("Init Failed: Refresh Page", "warn");
                console.error(e);
            }
        }

        // --- 2. Start System ---
        startBtn.addEventListener("click", async () => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();

            const constraints = { video: { facingMode: "user", width: 480, height: 360 } };
            
            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
                
                startBtn.classList.add("hidden");
                settingsArea.classList.remove("hidden");
                statusHeader.innerText = "ACTIVE";
                statusSub.innerText = "Scanning...";
                isMonitoring = true;
                log("Camera & HUD Active", "success");
            });
        });

        // --- 3. Main Loop ---
        async function predictWebcam() {
            if (!isMonitoring) return;

            // Resize canvas to match video
            if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
            }

            let startTimeMs = performance.now();
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, startTimeMs);
                processResults(results);
            }
            requestAnimationFrame(predictWebcam);
        }

        // --- 4. Processing & HUD Drawing ---
        function processResults(results) {
            // Clear Canvas
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

            if (results.faceBlendshapes && results.faceBlendshapes.length > 0) {
                const categories = results.faceBlendshapes[0].categories;
                const leftBlink = categories.find(c => c.categoryName === "eyeBlinkLeft").score;
                const rightBlink = categories.find(c => c.categoryName === "eyeBlinkRight").score;
                const avgBlink = (leftBlink + rightBlink) / 2;
                
                // Draw HUD Lines
                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];
                    const isDanger = avgBlink > BLINK_THRESHOLD;
                    
                    // Set Color: Green if Open, Red if Closed
                    const color = isDanger ? "#EF4444" : "#10B981"; // Red-500 vs Emerald-500
                    const lineWidth = 2;

                    drawEyeLoop(landmarks, LEFT_EYE_INDICES, color, lineWidth);
                    drawEyeLoop(landmarks, RIGHT_EYE_INDICES, color, lineWidth);
                }

                // Meter Logic
                const pct = Math.round(avgBlink * 100);
                blinkBar.style.width = `${pct}%`;

                // Alarm Logic
                if (avgBlink > BLINK_THRESHOLD) {
                    blinkBar.classList.replace("bg-emerald-500", "bg-red-500");
                    handleEyesClosed(true);
                } else {
                    blinkBar.classList.replace("bg-red-500", "bg-emerald-500");
                    handleEyesClosed(false);
                }
            }
        }

        // --- Helper: Draw Lines on Canvas ---
        function drawEyeLoop(landmarks, indices, color, width) {
            canvasCtx.beginPath();
            canvasCtx.strokeStyle = color;
            canvasCtx.lineWidth = width;
            
            // First point
            const p0 = landmarks[indices[0]];
            canvasCtx.moveTo(p0.x * canvas.width, p0.y * canvas.height);

            // Loop rest
            for (let i = 1; i < indices.length; i++) {
                const p = landmarks[indices[i]];
                canvasCtx.lineTo(p.x * canvas.width, p.y * canvas.height);
            }
            canvasCtx.closePath();
            canvasCtx.stroke();
            
            // Glow Effect
            canvasCtx.shadowBlur = 10;
            canvasCtx.shadowColor = color;
            canvasCtx.stroke();
            canvasCtx.shadowBlur = 0; // Reset
        }

        // --- 5. Alarm Logic ---
        function handleEyesClosed(isClosed) {
            if (isClosed) {
                if (eyesClosedStart === 0) {
                    eyesClosedStart = Date.now();
                    statusHeader.innerText = "WARNING";
                    statusHeader.className = "text-4xl font-bold text-yellow-400";
                    mainIcon.innerText = "üòë";
                }

                // Time check
                const duration = Date.now() - eyesClosedStart;
                if (duration > ALARM_DELAY_MS && !alarmTriggered) {
                    triggerAlarm();
                }
            } else {
                eyesClosedStart = 0;
                stopAlarm();
                if(!alarmTriggered) {
                    statusHeader.innerText = "SAFE";
                    statusHeader.className = "text-4xl font-extrabold text-emerald-400";
                    mainIcon.innerText = "üëÅÔ∏è";
                }
            }
        }

        function triggerAlarm() {
            if (alarmTriggered) return;
            alarmTriggered = true;
            isSirenOn = true;
            
            document.body.classList.add("alarm-active");
            statusHeader.innerText = "DANGER";
            statusHeader.className = "text-5xl font-black text-red-500";
            mainIcon.innerText = "üö®";
            playSiren();
        }

        function stopAlarm() {
            if (!alarmTriggered) return;
            alarmTriggered = false;
            isSirenOn = false;
            
            document.body.classList.remove("alarm-active");
            if (oscillator) {
                try { oscillator.stop(); oscillator.disconnect(); } catch(e){}
                oscillator = null;
            }
        }

        function playSiren() {
            if (!audioCtx) return;
            
            oscillator = audioCtx.createOscillator();
            gainNode = audioCtx.createGain();
            
            oscillator.type = 'square';
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            
            // Fast siren
            let high = true;
            const loop = setInterval(() => {
                if (!isSirenOn) { clearInterval(loop); return; }
                if (oscillator) oscillator.frequency.setValueAtTime(high ? 800 : 1200, audioCtx.currentTime);
                high = !high;
            }, 150);
            
            oscillator.start();
        }

        // Sensitivity Slider
        sensitivityInput.addEventListener('input', (e) => {
            BLINK_THRESHOLD = parseFloat(e.target.value);
            sensVal.innerText = Math.round(((0.8 - BLINK_THRESHOLD) / 0.5) * 100) + "%";
        });

        initAI();
    </script>
</body>
</html>


